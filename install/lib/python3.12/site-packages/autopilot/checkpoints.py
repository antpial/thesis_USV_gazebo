#!/usr/bin/env python3
#
# In this script boat sails to given checkpoints
#

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import MagneticField
import math
from std_msgs.msg import Float64
from sensor_msgs.msg import NavSatFix
from dataclasses import dataclass
from collections import deque
import copy

@dataclass
class GpsState:
    lat: float = 0.0
    lon: float = 0.0

@dataclass
class MagState:
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0



class Checkpoints_node(Node):
    def __init__(self):
        super().__init__('Checkpoints_node')

        # Parametry ruchu
        self.v = 1.0    # predkosc
        self.given_position = GpsState(lat= -33.721365, lon=150.675268)  # punkt docelowy
        self.p = 0.05 # parametr regulatora P
        self.alpha = 0.1 # wspolczynnik filtra dolnoprzepustowego dla azymutu docelowego

        # Dane pomiarowe
        self.current_position = GpsState()
        self.mag_vector = MagState()

        # Sterowanie
        self.d = 0.0    # skret (-1 do 1)
        self.e = 0.0    # blad (potrzebny azymut - aktualny azymut)
        self.left_thrust = 0.0  # moc lewego silnika [-1,1]
        self.right_thrust = 0.0 # moc prawego silnika [-1,1]


        # Azymuty
        self.given_azimuth = 0.0    # azymut do punktu docelowego
        self.current_azimuth = 0.0  # aktualny azymut



        # Subskrybujem /magnetometer
        self.subscription = self.create_subscription(
            MagneticField,
            '/magnetometer',
            self.mag_callback,
            10
        )
        self.get_logger().info("Magnetometer subscriber started!")

        # Subskrybuje /gps
        self.subscription = self.create_subscription(
            NavSatFix,
            '/gps',
            self.gps_callback,
            10
        )
        self.get_logger().info("Gps subscriber started!")

        # publishery na silniki
        self.left_pub = self.create_publisher(Float64, '/left_thrust', 10)
        self.right_pub = self.create_publisher(Float64, '/right_thrust', 10)


        # timer gdzie sie dzieje cala magia
        self.timer = self.create_timer(0.1, self.control_loop)

    # Callbacki do subskrybcji

    def mag_callback(self, msg: MagneticField):

        self.mag_vector.x = msg.magnetic_field.x
        self.mag_vector.y = msg.magnetic_field.y
        self.mag_vector.z = msg.magnetic_field.z

    def gps_callback(self, msg: NavSatFix):
        self.current_position.lat = msg.latitude
        self.current_position.lon = msg.longitude



    def publish_thrust(self):

        # Normuje skret. Nie moze przekraczac [-1,1]
        if(self.d < -1):
            self.d = -1
        if(self.d > 1):
            self.d = 1

        # Kalkuluje skret d na moc na silniku
        if(self.d <= 0):
            self.left_thrust = self.v * (1 + 2 * self.d)
            self.right_thrust = self.v
        else:
            self.left_thrust = self.v
            self.right_thrust = self.v * (1 - 2 * self.d)

        msg_left = Float64()
        msg_right = Float64()
        msg_left.data = self.left_thrust
        msg_right.data = self.right_thrust


        msg_left.data = self.left_thrust
        msg_right.data = self.right_thrust

        self.left_pub.publish(msg_left)
        self.right_pub.publish(msg_right)

    def calculate_new_azimuth(self):
        # zamiana stopni na radiany
        phi1 = math.radians(self.current_position.lat)
        phi2 = math.radians(self.given_position.lat)
        d_lambda = math.radians(self.given_position.lon - self.current_position.lon)
        y = math.sin(d_lambda) * math.cos(phi2)
        x = math.cos(phi1) * math.sin(phi2) - math.sin(phi1) * math.cos(phi2) * math.cos(d_lambda)
        theta = math.atan2(y, x)
        bearing = (math.degrees(theta) + 360) % 360
        return bearing  
    

    def calculate_current_azimuth(self):
        # obliczam kat sredniego wektora pola magnetycznego
        theta_rad = math.atan2(self.mag_vector.y, self.mag_vector.x)

        # Konwertuje z rad na stopnie
        theta_deg = math.degrees(theta_rad)     

        # atan2 oblicza kat od osi x, a polnoc jest na osi y, wiec trzeba obrocic
        azimuth = theta_deg + 90.0

        # atan 2 daje wartosc w przedziale (-pi,pi), a nie (0,2pi), a wiec dla
        # azymutu z przedzialu (180,360) musimy przekalkulowac
        if(azimuth < 0):
            azimuth += 360.0

        return azimuth



    def control_loop(self):

        # kalkuluje aktualny azymut
        self.current_azimuth = self.calculate_current_azimuth()

        # kalkuluje docelowy azymut (przepuszczam przez filtr dolnoprzepustowy bo gps jest zaszumiony)
        self.given_azimuth = self.alpha * self.calculate_new_azimuth() + (1 - self.alpha) * self.given_azimuth

        # licze blad normalizujac bo w stopniach jest modulo 360
        self.e = (self.given_azimuth - self.current_azimuth + 180.0) % 360.0 - 180.0

        # steruje wartoscia d (skret) regulatorem P
        self.d = self.e * self.p

        # ustawiam ciag na silnikach
        self.publish_thrust()

        # Logowanie lub publikacja
        self.get_logger().info("-------------------------------------------------------")
        self.get_logger().info(f"Given: {self.given_azimuth:.2f}°, Azymut: {self.current_azimuth:.2f}°, e = {self.e:.2f}°")
        self.get_logger().info(f"d: {self.d:.2f}%, v: {self.v}%, T_L: {self.left_thrust:.2f}%, T_R: {self.right_thrust:.2f}%")
        self.get_logger().info(f"curr. lat.: {self.current_position.lat:.6f}, curr. lon.: {self.current_position.lon:.6f}" )




def main(args=None):
    rclpy.init(args=args)
    node = Checkpoints_node()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
